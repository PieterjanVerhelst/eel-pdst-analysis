---
title: "Vertical movement analysis"
author: "Pieterjan Verhelst (pieterjan.verhelst@inbo.be)"
date: "17-2-2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
Eels were tracked from the Belgian coast (Nieuwpoort) through the North Sea as they migrate to their spawning grounds in the Atlantic Ocean. See [our article](https://www.nature.com/articles/s41598-021-04052-7) for the migration routes. In brief, the routes were modeled through geolocation modelling based on logged data on temperature and depth obtained by data loggers that were externally attached to the eels. For more info on the method, we refer to the aforementioned article. In general, we found that the eels can take 2 routes: a northern route over the UK or a southern route through the English Channel.

Now that we analysed the horizontal movement patterns (i.e. the migration routes), we want to analyse the vertical movement patterns. This can provide information on how eels orient themselves or move in a bio-energetic efficient way. Two of our key questions is if the eels have a circadian pattern in their vertical movement and if they apply selective tidal stream transport (STST). It is known that eels apply a diel vertical migration pattern in the Atlantic Ocean: they dive to depths of ca. 800 m during daytime, but swim at depths of ca. 200 m during night time (see [this article](https://www.science.org/doi/abs/10.1126/science.1178120)). However, it is unknown if eels show this or another pattern on the shallow continental shelf. Considering STST, this mode of transport has been illustrated for eels in [estuaries](https://www.sciencedirect.com/science/article/abs/pii/S0272771418304530). Since the North Sea and the English Channel have strong prevailing tidal currents, it is plausible that eels apply STST as well and hence behave differently during the ebbing and flooding tide.
To gain more insight in the vertical movement pattern, we want to analyse the eel's swimming depth (**depth measurements every 5 minutes**) over time in relation to the next relevant explanatory variables, being:

+	**Eastward current velocity (m/s) U** *	    &rarr; Obtained from tidal model
+	**Northward current velocity (m/s) V** *    		&rarr; Obtained from tidal model
+	**Water temperature (Â°C)**		                	&rarr; Measured by data loggers
+	**Illuminated moon fraction (percentage)**    	&rarr; Obtained from suncalc R-package
+	**Day or night**					                      &rarr; Obtained from suncalc R-package
+	**Sun altitude**					                      &rarr; Obtained from suncalc R-package
+	**Sun azimuth**					                      &rarr; Obtained from suncalc R-package

*Water currents are calculated as eastward and northward velocity vectors. 
Since the eels took 2 routes, I would split up the analysis for eels taking the southern route and eels taking the northern route.



## Set time zone
```{r}
Sys.setenv(TZ='GMT')
Sys.timezone()
```

## Load packages
```{r}
library(tidyverse)
library(lubridate)
library(mgcv)
#library(splines) # for bs function
#library(REdaS)
library(car)
#library(sjPlot)
#library(EnvStats)
library(pracma)
library(nlme) # for gls()
library(gridExtra)
library(forecast) # for auto.arima() function
library(tseries) # for Augmented Dickey-Fuller Test (adf.test())
library(visreg)
library(itsadug)
```


## Load dataset of 42 eels and set columns
```{r}
data <- read.csv("./data/interim/data_circadian_tidal_moon_sun_5min.csv")
data$ID <- factor(data$ID)
data$datetime <- ymd_hms(data$datetime)
data$night_day <- factor(data$night_day)
data <- data %>%
            rename(direction_x = U,
                   direction_y = V)
```

## Subset 1 eel for testing
```{r}
data_1eel <- filter(data, ID == "16031")

```


## ACF plot
Create an autocorrelation function plot to explore the cyclic signals in the data. The horizontal blue lines in the plot indicate the confidence interval in the correlogram.
First create plot for total dataset.

```{r}
forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=max(dim(data_1eel)), plot = TRUE)  
```

Next, create the ACF plot for the first 500 observations.
```{r}
forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=500, plot = TRUE)
```

In the plot above, we see 2 cycles subsequently returning. The first is probably related to a tidal signal, as it occurs ca. every 12 hours at lag 144: (12 hours x 60 minutes) / 5 minutes = 144

The second is probably related to a circadian rythm with a 24 h pattern at ca. lag 288: (24 hours x 60 minutes) / 5 minutes = 288

To illustrate this, we added a green vertical line at lag 144 and a blue line at lag 288 to the plot.

```{r}
vals_list <- forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=max(dim(data_1eel)), plot = FALSE)
plot(vals_list[[1]], xlim=c(0, 1000))
abline(v = 144, col = "darkgreen")
abline(v = 288, col = "darkblue")
```

## Depth data processing
The depth sensors are not 100% accurate. Hence, it can occur that when an eel is swimming close to the surface, the depth sensor registers a value as if the eel would be above the surface. Also, the depth sensors drift over time. A linear regression between the start of data logging (= when the tag was at zero atmospheric pressure) and the moment the tag surfaced (= when the tag was again at zero atmospheric pressure) was conducted at an earlier stage (to generate the trajectories). Hence the variable name 'corrected' depth.
```{r}
plot(data_1eel$corrected_depth, col = rgb(red = 0.5, green = 0.5, blue = 0.5, alpha = 0.2))
```
```{r}
summary(data_1eel$corrected_depth)
```

## Add daily max depth to dataset
```{r}
data_max_depth <- data_1eel %>%
  group_by(ID, Date) %>%
  summarise(max_depth = min(corrected_depth))
data_1eel <- left_join(data_1eel, data_max_depth, by = c("ID","Date"))
```


# Add daily bathymetry based on the trajectory files obtained from the geolocation models

```{r}
# Link trajectory data (source trajectory data script)
tr_data <- read_csv("./data/external/trajectory_data/eel_trajectories.csv")

# Select columns
tr_data <- dplyr::select(tr_data, ID, Date, Max_Depth)
tr_data <- rename(tr_data, 
                  max_depth_bathymetry = Max_Depth)

# Process columns
tr_data$Date <- dmy(tr_data$Date)
tr_data$ID <- factor(tr_data$ID)

# Remove double dates per eel (ID)
#tr_data <- tr_data[!duplicated(tr_data[c('ID','Date')]),]
tr_data <- tr_data %>%     # Add ID number to duplicate dates
  group_by(ID, Date) %>%
  add_tally()

duplicates <- filter(tr_data, n == 2)   # Filter duplicate dates
duplicates <- duplicates %>%             # Add ID number to distinguish between first and second duplicate
  mutate(number_id = row_number())
duplicates <- filter(duplicates, number_id == 2)  # Filter second duplicates

tr_data <- filter(tr_data, n != 2)   # Remove duplicate dates from tracking dataset

# Bind 'duplicates' dataset with second duplicates to tracking dataset
tr_data <- ungroup(tr_data)
tr_data$n <- NULL
duplicates <- ungroup(duplicates)
duplicates$n <- NULL
duplicates$number_id <- NULL

tr_data <- rbind(tr_data, duplicates)

# Select relevant eels
tr_data <- filter(tr_data, ID == "16031" )
tr_data$ID <- factor(tr_data$ID) # rerun 'factor()' so the number of levels is set accurately

data_1eel$Date <- as.Date(data_1eel$Date)
data_1eel <- left_join(data_1eel, tr_data, by = c('ID', 'Date'))

# Remove line with max depth bathymetry > 300 m --> remove location in deep sea
data_1eel$max_depth_bathymetry <- -1*(as.numeric(data_1eel$max_depth_bathymetry))
data_1eel <- filter(data_1eel, max_depth_bathymetry >= -300)
```


Plot the daily depth range, the max depth and the max depth bathymetry. The latter 2 do not differ a lot because one of the assumptions in the geolocation model is that the eel's daily depth is the daily max bathymetry.

```{r, fig.cap = "Three depth variables over time for 1 eel: corrected swimming depth, daily maximum depth and the daily maximum bathymetry obtained via the geolocation model."}
par(mfrow=c(3,1))
plot(data_1eel$Date, data_1eel$corrected_depth)
plot(data_1eel$Date, data_1eel$max_depth)
plot(data_1eel$Date, data_1eel$max_depth_bathymetry)
```


## Calculate the relative depth
Eels are known to reside near the bottom. Therefore, it can be reasonably assumed that the daily max swimming depth corresponds with the max daily bathymetry. Hence, the relative depth is calculated as the swimming depth divided by the max depth of that day.
```{r, fig.cap = "Plot of the relative depth for 1 eel."}
data_1eel$rel_depth <- data_1eel$corrected_depth / data_1eel$max_depth
plot(data_1eel$Date, data_1eel$rel_depth, col = rgb(red = 0.5, green = 0.5, blue = 0.5, alpha = 0.4))
```


## Exploratory plots
### Vertical depth pattern over time
```{r, fig.cap = "Vertical movement pattern for 1 eel."}
ggplot(data_1eel, aes(x = datetime,
                                   y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of vertical movement behaviour
In this plot a distinctive behaviour can be observed between day and night; the vertical red line indicates midnight. During the daytime, the eels have a steady depth, while at night they have a higher vertical amplitude in the water column. Also, there are moments where the eel remains near the bottom which I think is attributed to the tides.
```{r}
data_1eel_10days <- filter(data_1eel,datetime >= "2019-02-01 00:00:00", datetime <= "2019-02-11 00:00:00")

# Create line every 24 hours
gnu <-  seq.POSIXt(from = lubridate::floor_date(data_1eel_10days$datetime[1], "day"), to= data_1eel_10days$datetime[nrow(data_1eel_10days)], by = 86400)
class(lubridate::floor_date(data_1eel_10days$datetime[1], "day"))
```

```{r, fig.cap = "10-day detail of the vertical movement pattern for 1 eel."}
ggplot(data_1eel_10days, aes(x = datetime,
                                       y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Relative depth over time 
```{r, fig.cap = "The relative depth for 1 eel."}
ggplot(data_1eel, aes(x = datetime,
                                   y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of relative depth
```{r, fig.cap = "10-day detail of the relative depth for 1 eel."}
ggplot(data_1eel_10days, aes(x = datetime,
                                       y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Temperature over time
```{r, fig.cap = "Water temperature pattern for 1 eel."}
ggplot(data_1eel, aes(x = datetime,
                                 y = temperature)) +
  geom_line() +
  theme_minimal() +
  ylab("Temperature (Â°C))") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of temperature

```{r, fig.cap = "10-day detail of the water temperature pattern for 1 eel."}
ggplot(data_1eel_10days, aes(x = datetime,
                                   y = temperature)) +
  geom_line() +
  theme_minimal() +
  ylab("Temperature (Â°C))") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Plot relative depth over temperature
```{r, fig.cap = "Relative depth over temperature for 1 eel."}
ggplot(data_1eel, aes(x = temperature,
                                 y = rel_depth)) +
  geom_point(alpha = 0.1) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Temperature (Â°C)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth over temperature
```{r, fig.cap = "10-day detail of the relative depth over temperature pattern for 1 eel."}
ggplot(data_1eel_10days, aes(x = temperature,
                                 y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Temperature (Â°C)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```


### Plot bathymetry over time
```{r, fig.cap = "Daily max depth for 1 eel."}
ggplot(data_1eel, aes(x = datetime,
                                 y = max_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot vertical depth pattern over bathymetry
```{r, fig.cap = "Vertical movement pattern over the daily max depth for 1 eel."}
ggplot(data_1eel, aes(x = max_depth,
                                 y = corrected_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth over eastward current velocity vector
```{r, fig.cap = "Relative depth over eastward current velocity for 1 eel."}
ggplot(data_1eel, aes(x = direction_x,
                                       y = rel_depth)) +
  geom_point(alpha = 0.1) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Eastward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14))
```

### Plot detail relative depth over eastward current velocity vector

```{r, fig.cap = "10-day detail of the relative depth over eastward current velocity for 1 eel."}
ggplot(data_1eel_10days, aes(x = direction_x,
                                       y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Eastward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14))
```

### Plot relative depth over northward current velocity vector
```{r, fig.cap = "Relative depth over northward current velocity for 1 eel."}
ggplot(data_1eel, aes(x = direction_y,
                                   y = rel_depth)) +
  geom_point(alpha = 0.1) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Northward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot detail relative depth over northward current velocity vector
```{r, fig.cap = "10-day detail of the relative depth over northward current velocity for 1 eel."}
ggplot(data_1eel_10days, aes(x = direction_y,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Northward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```



### Plot relative depth pattern over day and night
Note that there is not a big difference because the depth range between day and night is equal, but the pattern is not.
```{r, fig.cap = "Relative depth during daytime and at night for 1 eel."}
ggplot(data_1eel, aes(x = night_day,
                                   y = rel_depth)) +
  geom_point(alpha = 0.1) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Circadian phases") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over illuminated moon phase
```{r, fig.cap = "Relative depth over illuminated fraction of the moon for 1 eel."}
ggplot(data_1eel, aes(x = 100*moon_fraction,
                                   y = rel_depth)) +
  geom_point(alpha = 0.2) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Illuminated moon phase (%)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over illuminated moon phase
```{r, fig.cap = "10-day detail of the relative depth over illuminated fraction of the moon for 1 eel."}
ggplot(data_1eel_10days, aes(x = 100*moon_fraction,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Illuminated moon phase (%)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over sun altitude
```{r, fig.cap = "The relative depth over the sun altitude for 1 eel."}
ggplot(data_1eel, aes(x = sun_altitude,
                                   y = rel_depth)) +
  geom_point(alpha = 0.2) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun altitude (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over sun altitude
```{r, fig.cap = "10-day detail of the relative depth over the sun altitude for 1 eel."}
ggplot(data_1eel_10days, aes(x = sun_altitude,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun altitude (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```


### Plot relative depth pattern over sun class i.e. sunset or sunrise

```{r}
#plot(data_1eel$sun_altitude)
data_1eel$sun_class <- NA
for (i in 2:dim(data_1eel)[1]){
  if (data_1eel$sun_altitude[i] > data_1eel$sun_altitude[i-1]){
    data_1eel$sun_class[i] = "rising"
  } else{
    data_1eel$sun_class[i] = "setting"
  }}


data_1eel$sun_class <- factor(data_1eel$sun_class)

```

Note that there is not a big difference between sunrise and sunset because the depth range between day and night is equal, but the pattern is not. The NA is due to the first record of the dataset, for which a sun class could not be attributed according to the rule in the if-else loop.
```{r, fig.cap = "Relative depth over the two different sun classes (sunrise and sunset) for 1 eel."}
ggplot(data_1eel, aes(x = sun_class,
                                   y = rel_depth)) +
  geom_point(alpha = 0.2) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun phase") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over sun azimuth

```{r, fig.cap = "Relative depth over the sun azimuth for 1 eel."}
ggplot(data_1eel, aes(x = sun_azimuth,
                                   y = rel_depth)) +
  geom_point(alpha = 0.2) +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun azimuth (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over sun azimuth
```{r, fig.cap = "10-day detail of the relative depth over the sun azimuth for 1 eel."}
ggplot(data_1eel_10days, aes(x = sun_azimuth,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun azimuth (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```


## Scale variables
For model construction, the exploratory variables need to be scaled. Max value should be between 0.5 - 5. 

```{r}
# direction_x
summary(data_1eel$direction_x)
#iqr <- 0.312  - (-0.284 )   #3rd QU - 1st Qu
#data_1eel$direction_x_centre <- (data_1eel$direction_x - median(data_1eel$direction_x))/iqr

# direction_y
summary(data_1eel$direction_y)
#iqr <- 0.199 - (-0.172)   #3rd QU - 1st Qu
#data_1eel$direction_y_centre <- (data_1eel$direction_y - median(data_1eel$direction_y))/iqr

# Temperature
summary(data_1eel$temperature)
#iqr <- 10.688  - (9.266 )   #3rd QU - 1st Qu
#data_1eel$temperature_centre <- (data_1eel$temperature - median(data_1eel$temperature))/iqr
data_1eel$temperature_scaled <- data_1eel$temperature / 10

# Moon illumination
summary(data_1eel$moon_fraction)
#iqr <- 0.7966425   - (0.1311380)   #3rd QU - 1st Qu
#data_1eel$moon_fraction_centre <- (data_1eel$moon_fraction - median(data_1eel$moon_fraction))/iqr

# Sun altitude
summary(data_1eel$sun_altitude)
#iqr <- 0.1584   - (-0.7657)   #3rd QU - 1st Qu
#data_1eel$sun_altitude_centre <- (data_1eel$sun_altitude - median(data_1eel$sun_altitude))/iqr

# Sun azimuth
summary(data_1eel$sun_azimuth)
#iqr <- 1.322311    - (-1.326227)   #3rd QU - 1st Qu
#data_1eel$sun_azimuth_centre <- (data_1eel$sun_azimuth - median(subset$sun_azimuth))/iqr


```


## Detrend the response variable
In case it would be needed, the response variable is detrended by subtracting a value by the previous value.
```{r}
data_1eel <- data_1eel %>% 
  group_by(ID) %>%
  arrange(datetime) %>%
  mutate(diff_rel_depth = rel_depth - lag(rel_depth))

```
```{r}
par(mfrow=c(2,1))
plot(data_1eel$datetime, data_1eel$rel_depth)
plot(data_1eel$datetime, data_1eel$diff_rel_depth)
```

Check ACF & PACF plot if data is stationary
```{r}
forecast::Acf(data_1eel$diff_rel_depth, type = c("correlation"), lag.max=20, plot = TRUE)
```

```{r}
forecast::Pacf(data_1eel$diff_rel_depth, lag.max=20, plot = TRUE)
```

## Conduct model on a subset of 5 eels

Next, a model was applied to a subset of 5 eels with a similar migration path (through the Channel). I want to apply this complex model first on only a few fish before scaling up the complexity. 

### Load packages
```{r}
library(lme4)
library(glmmTMB)
```

### Subset 5 eels for testing
```{r}
data_5eels <- filter(data, ID == "16031" |
                   ID == "17535" |
                   ID == "17536" |
                   ID == "15777" |
                   ID == "17510")

data_5eels$ID <- factor(data_5eels$ID)
unique(data_5eels$ID)

```

### Remove data from eel 17535 when it was in the Atlantic Ocean
For this study I am interested in the vertical movement behaviour on the contintental shelf. The vertical behaviour in oceanic conditions has already been described.
```{r}
data_5eels <- data_5eels[!(data_5eels$ID == "17535" & data_5eels$datetime > '2020-01-11 00:00:00'),]
```


### Depth data processing
```{r}
plot(data_5eels$corrected_depth)
```



### Add daily max depth
```{r}
max_depth <- data_5eels %>%
  group_by(ID, Date) %>%
  summarise(max_depth = min(corrected_depth))
data_5eels <- left_join(data_5eels, max_depth, by = c("ID","Date"))
```


### Add daily bathymetry based on the trajectory files obtained from the geolocation models

Note that I will not use this, but leave the code as is just in case.

```{r}
# Link trajectory data (source trajectory data script)
tr_data <- read_csv("./data/external/trajectory_data/eel_trajectories.csv")

# Select columns
tr_data <- dplyr::select(tr_data, ID, Date, Max_Depth)
tr_data <- rename(tr_data, 
                  max_depth_bathymetry = Max_Depth)

# Process columns
tr_data$Date <- dmy(tr_data$Date)
tr_data$ID <- factor(tr_data$ID)

# Remove double dates per eel (ID)
#tr_data <- tr_data[!duplicated(tr_data[c('ID','Date')]),]
tr_data <- tr_data %>%     # Add ID number to duplicate dates
  group_by(ID, Date) %>%
  add_tally()

duplicates <- filter(tr_data, n == 2)   # Filter duplicate dates
duplicates <- duplicates %>%             # Add ID number to distinguish between first and second duplicate
  mutate(number_id = row_number())
duplicates <- filter(duplicates, number_id == 2)  # Filter second duplicates

tr_data <- filter(tr_data, n != 2)   # Remove duplicate dates from tracking dataset

# Bind 'duplicates' dataset with second duplicates to tracking dataset
tr_data <- ungroup(tr_data)
tr_data$n <- NULL
duplicates <- ungroup(duplicates)
duplicates$n <- NULL
duplicates$number_id <- NULL

tr_data <- rbind(tr_data, duplicates)

# Select relevant eels
tr_data <- filter(tr_data, ID == "16031" |
                   ID == "17535" |
                   ID == "17536" |
                   ID == "15777" |
                   ID == "17510")

tr_data$ID <- factor(tr_data$ID) # rerun 'factor()' so the number of levels is set accurately

data_5eels$Date <- as.Date(data_5eels$Date)
data_5eels <- left_join(data_5eels, tr_data, by = c('ID', 'Date'))

# Remove line with max depth bathymetry > 300 m --> remove location in deep sea
#data_5eels$max_depth_bathymetry <- as.numeric(data_5eels$max_depth_bathymetry)
#data_5eels <- filter(data_5eels, max_depth_bathymetry >= -300)
```


Plot the daily depth range, the max depth and the max depth bathymetry. The latter 2 do not differ a lot because one of the assumptions in the geolocation model is that the eel's daily depth is the daily max bathymetry.

```{r}
par(mfrow=c(3,1))
plot(data_5eels$Date, data_5eels$corrected_depth)
plot(data_5eels$Date, data_5eels$max_depth)
plot(data_5eels$Date, data_5eels$max_depth_bathymetry)
```


### Calculate the relative depth
```{r}
data_5eels$rel_depth <- data_5eels$corrected_depth / data_5eels$max_depth
plot(data_5eels$Date, data_5eels$rel_depth)
```

### Create factor indicating if the sun is rising or setting


```{r}
# Remove rows with NA values
data_5eels <- na.omit(data_5eels)

# Classify sun_altitude as rising or setting sun
data_5eels$sun_class <- NA
  for (i in 2:dim(data_5eels)[1]){
    if (data_5eels$sun_altitude[i] > data_5eels$sun_altitude[i-1]){
      data_5eels$sun_class[i] = "rising"
    } else{
      data_5eels$sun_class[i] = "setting"
    }}

# Set as factor
data_5eels$sun_class <- factor(data_5eels$sun_class)

# Remove first line of each eel, since that "sun_class" value is incorrect. The for-loop does not take into account different eels, but runs over the complete dataset.
data_5eels <- data_5eels %>%
  group_by(ID) %>%
  slice(-1)

```


## Scale variables
For model construction, the exploratory variables need to be scaled. Max value should be between 0.5 - 5. 


```{r}
# direction_x
summary(data_5eels$direction_x)

# direction_y
summary(data_5eels$direction_y)

# Temperature
summary(data_5eels$temperature)
data_5eels$temperature_scaled <- data_5eels$temperature / 10

# Moon illumination
summary(data_5eels$moon_fraction)

# Sun altitude
summary(data_5eels$sun_altitude)

# Sun azimuth
summary(data_5eels$sun_azimuth)

```

### Construct model with AR1 covariance structure
```{r}
data_5eels <- data_5eels %>%
  arrange(ID, datetime) %>%
  group_by(ID) %>%
  mutate(times = factor(row_number()))
```


#### glmer from lme4 package
When running the glmer() function, it gives an error. Not sure why, but based on fora searches it might have to do with the data complexity and/or size.
```{r}
#model_glmer <- glmer(rel_depth ~ direction_x_centre +
#                   direction_y_centre +
#                   moon_fraction_centre +
#                   sun_altitude_centre +
#                   sun_azimuth_centre +
#                 (1|ID),
#                 data = data_5eels,
#                 family = beta_family(),
#                 na.action = na.omit)
#summary(model_glmer)
```

Returns the following error:
```{r}
#  Error in (function (fr, X, reTrms, family, nAGQ = 1L, verbose = 0L, maxit = 100L, : 
#(maxstephalfit) PIRLS step-halvings failed to reduce deviance in pwrssUpdate
```

#### glmmTMB from the glmmTMB package
The function glmmTMB() runs when no AR1 construct is implemented.
For more info on the method implementation, see [this website](https://cran.r-project.org/web/packages/glmmTMB/vignettes/covstruct.html). The [glmmTMB ](https://cran.r-project.org/web/packages/glmmTMB/vignettes/glmmTMB.pdf) R-package was used.

Update: I included the positive corrected_depth values, hence, the rel_depth now contains negative values so a model with beta-distribution is unable to run.
```{r}
summary(data_5eels$rel_depth)
```


```{r}
#model_tmb <- glmmTMB(rel_depth ~ direction_x +
#                   direction_y +
#                   moon_fraction +
#                   sun_altitude +
#                   sun_azimuth,
#                 data = data_5eels,
#                 family = beta_family(),
#                 na.action = na.omit)
#summary(model_tmb)
```

When the AR1 term is added, a memory error occurs. This is probably due to the fact that this function is rather viable for datasets up to 100k (see [documentation](https://m-clark.github.io/posts/2019-10-20-big-mixed-models/))

```{r}
#model_tmb_ar1 <- glmmTMB(rel_depth ~ direction_x_centre +
#                   direction_y_centre +
#                   moon_fraction_centre +
#                   sun_altitude_centre +
#                   sun_azimuth_centre +
#                 ar1(times + 0 | ID),
#                 family = beta_family(),
#                 data = subset)

```

Returns the following error:
```{r}
#Error: cannot allocate vector of size 4.8 Gb
```

#### bam from the mgcv package
The function bam from the mgcv package is designed for large datasets (see [documentation](https://m-clark.github.io/posts/2019-10-20-big-mixed-models/)).

To implement the AR1 strucgture in the model, select the first record per eel and flag as true.
```{r}
# Select first record per eel and flag as 'TRUE'
t.first <- data_5eels[match(unique(data_5eels$ID), data_5eels$ID),]
t.first <- select(t.first, ID, datetime)
t.first$start.event <- TRUE

# Merge with dataset
data_5eels <- left_join(data_5eels, t.first, by = c("ID", "datetime"))

# Set NA as FALSE
data_5eels[c("start.event")][is.na(data_5eels[c("start.event")])] <- FALSE

```


```{r}
# Run gamm model with autocorrelation argument

# Full model
bam_model <- bam(rel_depth ~ s(direction_x) +
                   s(direction_y) +
                   s(moon_fraction) +
                   s(sun_altitude) +
                   s(sun_azimuth) +
                   sun_class +
                   s(ID, bs="re"),
                 family = gaussian(), data = data_5eels, discrete = TRUE,
                 #AR.start=subset$start.event, 
                 rho=0.90,
                 na.action = na.omit)

```

Calculate rho (= acf value) which can be fed into the bam_model for model optimisation.
However, this results in an error for a model of the beta family.
```{r}
# Calculate Rho, the autocorrelation value of a specific lag
#valRho <- acf(resid(bam_model), plot=TRUE)$acf[2]
```

```{r}
#Error in plot.window(...) : need finite 'ylim' values
```

Show summary of the model
```{r}
summary(bam_model)
```

Check the model
```{r}
par(mfrow = c(2, 2))
gam.check(bam_model)
```





# GAM on data of 1 eel
This document describes the GAM procedure following Zuur et al. (2012) 'Beginner's Guide to Generalized Additive Models with R'. The analysis is applied on a single eel (ID A16031) and a few days for simplicity. Spoiler alert: it shows that the model runs very good on a few days but is off when the amount of data (i.e. days of data) is increased.

# Subset on eel A16031
```{r}
subset_1eel <- filter(data_5eels, ID == "16031")
```

Plot the depth data. Note that the depth sensor data drifts. A linear regression was applied to correct for this drift, hence the variable name 'corrected_depth'. Also, the relative depth might be a better response variable and was calculated as the corrected_depth divided by the max depth for that day. It is assumed that the max depth resembles the sea bottom.
```{r}
ggplot(subset_1eel, aes(x = datetime, y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "5 days") 

ggplot(subset_1eel, aes(x = datetime, y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "5 days") 

```

# Subset two days of data in the beginning of the track, around half December
```{r}
subset_1eel_2days_1 <- filter(subset_1eel, datetime > '2018-12-12 00:00:00',
                              datetime < '2018-12-14 00:00:00')

ggplot(subset_1eel_2days_1, aes(x = datetime, y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 

ggplot(subset_1eel_2days_1, aes(x = datetime, y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

Apply the GAM. One with a Gaussian distribution and one with a binomial distribution (since the data is between 0 and 1). 
The explanatory variables I am interested in are the current variables (obtained via CEFAS model) and the factor with circadian phases 'day' or 'night'. The current variables are split in two vectors giving the current speed in direction 'x' and 'y'. Before the variables are fed into the GAM, a correlation analysis is applied between direction_x and direction_y. When a strong correlation (> |0.6|) is observed, variable 'direction_x' is chosen.

Despite the values of the response variable are between 0 and 1, indicating a binomial distribution, the GAM with a Gaussian distribution results in the best fit and lowest AIC. Further, note that the edf in the model output illustrate non-linear relationships.

```{r}
cor(subset_1eel_2days_1$direction_x, subset_1eel_2days_1$direction_y)

gam1 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_1)
gam2 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_1, family = binomial(link = "logit"))

AIC(gam1, gam2)

summary(gam1)

```

In a next step, the smoothers are plotted for the best model (gam1)
```{r}
par(mfrow = c(2,1))
plot(gam1, select = 1, main = "Day")
plot(gam1, select = 2, main = "Night")

```
Check model performance.
```{r}
par(mfrow = c(2, 2))
gam.check(gam1)

```

```{r}
subset_1eel_2days_1$residuals <- residuals(gam1, type="response")
subset_1eel_2days_1$predicted <- predict.bam(gam1)
subset_1eel_2days_1$fitted <- fitted(gam1, type="response")


plot <- ggplot(subset_1eel_2days_1, aes(x=numericdate, y=rel_depth)) +
  geom_line(alpha = 0.2) +
  geom_line(subset_1eel_2days_1, mapping = aes(x=numericdate, y=fitted), colour = "red") 
plot
```

```{r}
E1 <- resid(gam1, type = "pearson")
F1 <- fitted(gam1, type = "response")
par(mfrow = c(2,2))
plot(x = F1, y = E1, xlab = "Fitted values", ylab = "Pearson residuals")
plot(x = subset_1eel_2days_1$direction_x, y = E1, xlab = "Direction x", ylab = "Pearson residuals")
abline(h = 0, lty = 2)
plot(E1 ~ night_day, data = subset_1eel_2days_1, ylab = "Pearson residuals", xlab = "Day Night")
hist(E1, xlab = "Pearson residuals", main = "")
```

Check overdispersion
```{r}
E1 <- resid(gam1, type = "pearson")
N <- nrow(subset_1eel_2days_1)
p <- length(coef(gam1))
overdispersion <- sum(E1^2)/(N-p)
overdispersion
```


# Subset two days of data toward the end of the track when the vertical movement becomes more pronounced.
```{r}
subset_1eel_2days_2 <- filter(subset_1eel, datetime > '2019-02-04 00:00:00',
                              datetime < '2019-02-06 00:00:00')

ggplot(subset_1eel_2days_2, aes(x = datetime, y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 

ggplot(subset_1eel_2days_2, aes(x = datetime, y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

Apply GAM

```{r}
cor(subset_1eel_2days_2$direction_x, subset_1eel_2days_2$direction_y)

gam1 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_2)
gam2 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_2, family = binomial(link = "logit"))

AIC(gam1, gam2)

summary(gam1)

```

In a next step, the smoothers are plotted for the best model (gam1)
```{r}
par(mfrow = c(2,1))
plot(gam1, select = 1, main = "Day")
plot(gam1, select = 2, main = "Night")

```

Check model performance.
```{r}
par(mfrow = c(2, 2))
gam.check(gam1)

```

```{r}
subset_1eel_2days_2$residuals <- residuals(gam1, type="response")
subset_1eel_2days_2$predicted <- predict.bam(gam1)
subset_1eel_2days_2$fitted <- fitted(gam1, type="response")


plot <- ggplot(subset_1eel_2days_2, aes(x=numericdate, y=rel_depth)) +
  geom_line(alpha = 0.2) +
  geom_line(subset_1eel_2days_2, mapping = aes(x=numericdate, y=fitted), colour = "red") 
plot
```

```{r}
E1 <- resid(gam1, type = "pearson")
F1 <- fitted(gam1, type = "response")
par(mfrow = c(2,2))
plot(x = F1, y = E1, xlab = "Fitted values", ylab = "Pearson residuals")
plot(x = subset_1eel_2days_2$direction_x, y = E1, xlab = "Direction x", ylab = "Pearson residuals")
abline(h = 0, lty = 2)
plot(E1 ~ night_day, data = subset_1eel_2days_2, ylab = "Pearson residuals", xlab = "Day Night")
hist(E1, xlab = "Pearson residuals", main = "")
```

Check overdispersion
```{r}
E1 <- resid(gam1, type = "pearson")
N <- nrow(subset_1eel_2days_2)
p <- length(coef(gam1))
overdispersion <- sum(E1^2)/(N-p)
overdispersion
```


# Subset six days of data toward the end of the track when the vertical movement becomes more pronounced.
```{r}
subset_1eel_2days_6 <- filter(subset_1eel, datetime > '2019-02-04 00:00:00',
                              datetime < '2019-02-10 00:00:00')

ggplot(subset_1eel_2days_6, aes(x = datetime, y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 

ggplot(subset_1eel_2days_6, aes(x = datetime, y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

Apply GAM

Note that the RÂ² adj reduced by more than half (33%) by addding 4 more days of data.
```{r}
cor(subset_1eel_2days_6$direction_x, subset_1eel_2days_6$direction_y)

gam1 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_6)
gam2 <- gam(rel_depth ~ s(direction_x, by = night_day) + night_day, data = subset_1eel_2days_6, family = binomial(link = "logit"))

AIC(gam1, gam2)

summary(gam1)

```

In a next step, the smoothers are plotted for the best model (gam1)
```{r}
par(mfrow = c(2,1))
plot(gam1, select = 1, main = "Day")
plot(gam1, select = 2, main = "Night")

```

Check model performance. There seems to be a trend in de residuals.
```{r}
par(mfrow = c(2, 2))
gam.check(gam1)

```

The model fit is reduced substantially.
```{r}
subset_1eel_2days_6$residuals <- residuals(gam1, type="response")
subset_1eel_2days_6$predicted <- predict.bam(gam1)
subset_1eel_2days_6$fitted <- fitted(gam1, type="response")


plot <- ggplot(subset_1eel_2days_6, aes(x=numericdate, y=rel_depth)) +
  geom_line(alpha = 0.2) +
  geom_line(subset_1eel_2days_6, mapping = aes(x=numericdate, y=fitted), colour = "red") 
plot
```

```{r}
E1 <- resid(gam1, type = "pearson")
F1 <- fitted(gam1, type = "response")
par(mfrow = c(2,2))
plot(x = F1, y = E1, xlab = "Fitted values", ylab = "Pearson residuals")
plot(x = subset_1eel_2days_6$direction_x, y = E1, xlab = "Direction x", ylab = "Pearson residuals")
abline(h = 0, lty = 2)
plot(E1 ~ night_day, data = subset_1eel_2days_6, ylab = "Pearson residuals", xlab = "Day Night")
hist(E1, xlab = "Pearson residuals", main = "")
```

Check overdispersion
```{r}
E1 <- resid(gam1, type = "pearson")
N <- nrow(subset_1eel_2days_2)
p <- length(coef(gam1))
overdispersion <- sum(E1^2)/(N-p)
overdispersion
```


