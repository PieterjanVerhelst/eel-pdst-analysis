---
title: "Vertical movement analysis"
author: "Pieterjan Verhelst (pieterjan.verhelst@inbo.be)"
date: "17-2-2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
Eels were tracked from the Belgian coast (Nieuwpoort) through the North Sea as they migrate to their spawning grounds in the Atlantic Ocean. See [our article](https://www.nature.com/articles/s41598-021-04052-7) for the migration routes. In brief, the routes were modeled through geolocation modelling based on logged data on temperature and depth obtained by data loggers that were externally attached to the eels. For more info on the method, we refer to the aforementioned article. In general, we found that the eels can take 2 routes: a northern route over the UK or a southern route through the English Channel.

Now that we analysed the horizontal movement patterns (i.e. the migration routes), we want to analyse the vertical movement patterns. This can provide information on how eels orient themselves or move in a bio-energetic efficient way. Two of our key questions is if the eels have a circadian pattern in their vertical movement and if they apply selective tidal stream transport (STST). It is known that eels apply a diel vertical migration pattern in the Atlantic Ocean: they dive to depths of ca. 800 m during daytime, but swim at depths of ca. 200 m during night time (see [this article](https://www.science.org/doi/abs/10.1126/science.1178120)). However, it is unknown if eels show this or another pattern on the shallow continental shelf. Considering STST, this mode of transport has been illustrated for eels in [estuaries](https://www.sciencedirect.com/science/article/abs/pii/S0272771418304530). Since the North Sea and the English Channel have strong prevailing tidal currents, it is plausible that eels apply STST as well and hence behave differently during the ebbing and flooding tide.
To gain more insight in the vertical movement pattern, we want to analyse the eel's swimming depth (**depth measurements every 5 minutes**) over time in relation to the next relevant explanatory variables, being:

+	**Eastward current velocity (m/s) U** *	    &rarr; Obtained from tidal model
+	**Northward current velocity (m/s) V** *    		&rarr; Obtained from tidal model
+	**Water temperature (°C)**		                	&rarr; Measured by data loggers
+	**Illuminated moon fraction (percentage)**    	&rarr; Obtained from suncalc R-package
+	**Day or night**					                      &rarr; Obtained from suncalc R-package
+	**Sun altitude**					                      &rarr; Obtained from suncalc R-package
+	**Sun azimuth**					                      &rarr; Obtained from suncalc R-package

*Water currents are calculated as eastward and northward velocity vectors. Based on these two vectors, current speed and direction can be calculated. Note that the direction is circular data (range: -180° - 180°) which is not easily handled by linear models, hence, I used the orthogonal vectors instead.
Since the eels took 2 routes, I would split up the analysis for eels taking the southern route and eels taking the northern route.



## Set time zone
```{r}
Sys.setenv(TZ='GMT')
Sys.timezone()
```

## Load packages
```{r}
library(tidyverse)
library(lubridate)
library(mgcv)
#library(splines) # for bs function
#library(REdaS)
library(car)
#library(sjPlot)
#library(EnvStats)
library(pracma)
library(nlme) # for gls()
library(gridExtra)
library(forecast) # for auto.arima() function
library(tseries) # for Augmented Dickey-Fuller Test (adf.test())
library(visreg)
library(itsadug)
```


## Load dataset of 42 eels and set columns
```{r}
data <- read.csv("./data/interim/data_circadian_tidal_moon_sun_5min.csv")
data$ID <- factor(data$ID)
data$datetime <- ymd_hms(data$datetime)
data$night_day <- factor(data$night_day)
data <- data %>%
            rename(direction_x = U,
                   direction_y = V)
```

## Subset 1 eel for testing
```{r}
data_1eel <- filter(data, ID == "16031")

```


## ACF plot
Create an autocorrelation function plot to explore the cyclic signals in the data. The horizontal blue lines in the plot indicate the confidence interval in the correlogram.
First create plot for total dataset.

```{r}
forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=max(dim(data_1eel)), plot = TRUE)  
```

Next, create the ACF plot for the first 500 observations.
```{r}
forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=500, plot = TRUE)
```

In the plot above, we see 2 cycles subsequently returning. The first is probably related to a tidal signal, as it occurs ca. every 12 hours at lag 144: (12 hours x 60 minutes) / 5 minutes = 144

The second is probably related to a circadian rythm with a 24 h pattern at ca. lag 288: (24 hours x 60 minutes) / 5 minutes = 288

To illustrate this, we added a green vertical line at lag 144 and a blue line at lag 288 to the plot.

```{r}
vals_list <- forecast::Acf(data_1eel$corrected_depth, type = c("correlation"), lag.max=max(dim(data_1eel)), plot = FALSE)
plot(vals_list[[1]], xlim=c(0, 1000))
abline(v = 144, col = "darkgreen")
abline(v = 288, col = "darkblue")
```

## Depth data processing
The depth sensors are not 100% accurate. Hence, it can occur that when an eel is swimming close to the surface, the depth sensor registers a value as if the eel would be above the surface. Since this is incorrect, we remove these cases, leading to a dataset with negative values only. Next, with a model with Gamma distribution in mind, we turn these values into positive ones.
Side note: the depth sensors drift over time. A linear regression between the start of data logging (= when the tag was at zero atmospheric pressure) and the moment the tag surfaced (= when the tag was again at zero atmospheric pressure) was conducted at an earlier stage (to generate the trajectories). Hence the variable name 'corrected' depth.
```{r}
plot(data_1eel$corrected_depth)
```
```{r}
subset <- filter(data_1eel, corrected_depth < 0)
```
```{r}
plot(data_1eel$corrected_depth)
```
```{r}
summary(data_1eel$corrected_depth)
```
```{r}
data_1eel$corrected_depth_abs <- abs(data_1eel$corrected_depth)
summary(data_1eel$corrected_depth_abs)
```

## Add daily max depth
```{r}
data_max_depth <- data_1eel %>%
  group_by(ID, Date) %>%
  summarise(max_depth = max(corrected_depth))
data_1eel <- left_join(data_1eel, data_max_depth, by = c("ID","Date"))
```


# Add daily bathymetry based on the trajectory files obtained from the geolocation models

```{r}
# Link trajectory data (source trajectory data script)
tr_data <- read_csv("./data/external/trajectory_data/eel_trajectories.csv")

# Select columns
tr_data <- dplyr::select(tr_data, ID, Date, Max_Depth)
tr_data <- rename(tr_data, 
                  max_depth_bathymetry = Max_Depth)

# Process columns
tr_data$Date <- dmy(tr_data$Date)
tr_data$ID <- factor(tr_data$ID)

# Remove double dates per eel (ID)
#tr_data <- tr_data[!duplicated(tr_data[c('ID','Date')]),]
tr_data <- tr_data %>%     # Add ID number to duplicate dates
  group_by(ID, Date) %>%
  add_tally()

duplicates <- filter(tr_data, n == 2)   # Filter duplicate dates
duplicates <- duplicates %>%             # Add ID number to distinguish between first and second duplicate
  mutate(number_id = row_number())
duplicates <- filter(duplicates, number_id == 2)  # Filter second duplicates

tr_data <- filter(tr_data, n != 2)   # Remove duplicate dates from tracking dataset

# Bind 'duplicates' dataset with second duplicates to tracking dataset
tr_data <- ungroup(tr_data)
tr_data$n <- NULL
duplicates <- ungroup(duplicates)
duplicates$n <- NULL
duplicates$number_id <- NULL

tr_data <- rbind(tr_data, duplicates)

# Select relevant eels
tr_data <- filter(tr_data, ID == "16031" )
tr_data$ID <- factor(tr_data$ID) # rerun 'factor()' so the number of levels is set accurately

data_1eel$Date <- as.Date(data_1eel$Date)
data_1eel <- left_join(data_1eel, tr_data, by = c('ID', 'Date'))

# Remove line with max depth bathymetry > 300 m --> remove location in deep sea
data_1eel$max_depth_bathymetry <- as.numeric(data_1eel$max_depth_bathymetry)
data_1eel <- filter(data_1eel, max_depth_bathymetry < 300)
```


Plot the daily depth range, the max depth and the max depth bathymetry. The latter 2 do not differ a lot because one of the assumptions in the geolocation model is that the eel's daily depth is the daily max bathymetry.

```{r}
par(mfrow=c(3,1))
plot(data_1eel$Date, data_1eel$corrected_depth_abs)
plot(data_1eel$Date, data_1eel$max_depth)
plot(data_1eel$Date, data_1eel$max_depth_bathymetry)
```


## Calculate the relative depth
```{r}
data_1eel$rel_depth <- data_1eel$corrected_depth / data_1eel$max_depth_bathymetry
plot(data_1eel$Date, data_1eel$rel_depth)
```


## Exploratory plots
### Vertical depth pattern over time
```{r}
ggplot(data_1eel, aes(x = datetime,
                                   y = -1*corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of vertical movement behaviour
In this plot a distinctive behaviour can be observed between day and night; the vertical red line indicates midnight. During the daytime, the eels have a steady depth, while at night they have a higher vertical amplitude in the water column. Also, there are moments where the eel remains near the bottom which I think is attributed to the tides.
```{r}
data_1eel_10days <- filter(data_1eel,datetime >= "2019-02-01 00:00:00", datetime <= "2019-02-11 00:00:00")

# Create line every 24 hours
gnu <-  seq.POSIXt(from = lubridate::floor_date(data_1eel_10days$datetime[1], "day"), to= data_1eel_10days$datetime[nrow(data_1eel_10days)], by = 86400)
class(lubridate::floor_date(data_1eel_10days$datetime[1], "day"))
```

```{r}
ggplot(data_1eel_10days, aes(x = datetime,
                                       y = corrected_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Relative depth over time 
```{r}
ggplot(data_1eel, aes(x = datetime,
                                   y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of relative depth
```{r}
ggplot(data_1eel_10days, aes(x = datetime,
                                       y = rel_depth)) +
  geom_line() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Temperature over time
```{r}
ggplot(data_1eel, aes(x = datetime,
                                 y = temperature)) +
  geom_line() +
  theme_minimal() +
  ylab("Temperature (°C))") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot detail of temperature

```{r}
ggplot(data_1eel_10days, aes(x = datetime,
                                   y = temperature)) +
  geom_line() +
  theme_minimal() +
  ylab("Temperature (°C))") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  ="1 hour") +
  geom_vline(xintercept=gnu, color = "red", size = 1) 
```

### Plot relative depth over temperature
```{r}
ggplot(data_1eel, aes(x = temperature,
                                 y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Temperature (°C)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth over temperature
```{r}
ggplot(data_1eel_10days, aes(x = temperature,
                                 y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Temperature (°C)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```


### Plot bathymetry over time
```{r}
ggplot(data_1eel, aes(x = datetime,
                                 y = -1* max_depth_bathymetry)) +
  geom_point() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  scale_x_datetime(date_breaks  = "1 day") 
```

### Plot vertical depth pattern over bathymetry
```{r}
ggplot(data_1eel, aes(x = max_depth_bathymetry,
                                 y = corrected_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Depth (m)") +
  xlab("Date") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth over eastward current velocity vector
```{r}
ggplot(data_1eel, aes(x = direction_x,
                                       y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Eastward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14))
```

### Plot detail relative depth over eastward current velocity vector

```{r}
ggplot(data_1eel_10days, aes(x = direction_x,
                                       y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Eastward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14))
```

### Plot relative depth over northward current velocity vector
```{r}
ggplot(data_1eel, aes(x = direction_y,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Northward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot detail relative depth over northward current velocity vector
```{r}
ggplot(data_1eel_10days, aes(x = direction_y,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Northward current velocity (m/s)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```



### Plot relative depth pattern over day and night
Note that there is not a big difference because the depth range between day and night is equal, but the pattern is not.
```{r}
ggplot(data_1eel, aes(x = night_day,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Circadian phases") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over illuminated moon phase
```{r}
ggplot(data_1eel, aes(x = 100*moon_fraction,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Illuminated moon phase (%)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over illuminated moon phase
```{r}
ggplot(data_1eel_10days, aes(x = 100*moon_fraction,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Illuminated moon phase (%)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over sun altitude
```{r}
ggplot(data_1eel, aes(x = sun_altitude,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun altitude (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over sun altitude
```{r}
ggplot(data_1eel_10days, aes(x = sun_altitude,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun altitude (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```

### Plot relative depth pattern over sun azimuth

```{r}
ggplot(data_1eel, aes(x = sun_azimuth,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun azimuth (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```
### Plot detail relative depth pattern over sun azimuth
```{r}
ggplot(data_1eel_10days, aes(x = sun_azimuth,
                                   y = rel_depth)) +
  geom_point() +
  theme_minimal() +
  ylab("Relative depth (m)") +
  xlab("Sun azimuth (radians)") +
  theme(axis.title.y = element_text(margin = margin(r = 10))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 
```


## Centralise and normalise exploratory variables
For model construction, the exploratory variables need to be cenralised and normalised by substracting the median of each value and dividing it by the interquantile range

```{r}
# direction_x
summary(subset$direction_x)
iqr <- 0.312  - (-0.284 )   #3rd QU - 1st Qu
subset$direction_x_centre <- (subset$direction_x - median(subset$direction_x))/iqr

# direction_y
summary(subset$direction_y)
iqr <- 0.199 - (-0.172)   #3rd QU - 1st Qu
subset$direction_y_centre <- (subset$direction_y - median(subset$direction_y))/iqr

# Temperature
summary(subset$temperature)
iqr <- 10.688  - (9.266 )   #3rd QU - 1st Qu
subset$temperature_centre <- (subset$temperature - median(subset$temperature))/iqr

# Moon illumination
summary(subset$moon_fraction)
iqr <- 0.7966425   - (0.1311380)   #3rd QU - 1st Qu
subset$moon_fraction_centre <- (subset$moon_fraction - median(subset$moon_fraction))/iqr

# Sun altitude
summary(subset$sun_altitude)
iqr <- 0.1584   - (-0.7657)   #3rd QU - 1st Qu
subset$sun_altitude_centre <- (subset$sun_altitude - median(subset$sun_altitude))/iqr

# Sun azimuth
summary(subset$sun_azimuth)
iqr <- 1.322311    - (-1.326227)   #3rd QU - 1st Qu
subset$sun_azimuth_centre <- (subset$sun_azimuth - median(subset$sun_azimuth))/iqr

# Max depth bathymetry
summary(subset$max_depth_bathymetry)
iqr <-  64.36  - 34.41   #3rd QU - 1st Qu
subset$max_depth_bathymetry_centre <- (subset$max_depth_bathymetry - median(subset$max_depth_bathymetry))/iqr

```


## Detrend the response variable
In case it would be needed, the response variable is detrended by subtracting a value by the previous value.
```{r}
subset <- subset %>% 
  group_by(ID) %>%
  arrange(datetime) %>%
  mutate(diff_rel_depth = rel_depth - lag(rel_depth))

```
```{r}
par(mfrow=c(2,1))
plot(subset$datetime, subset$rel_depth)
plot(subset$datetime, subset$diff_rel_depth)
```

Check ACF & PACF plot if data is stationary
```{r}
forecast::Acf(subset$diff_rel_depth, type = c("correlation"), lag.max=20, plot = TRUE)
```

```{r}
forecast::Pacf(subset$diff_rel_depth, lag.max=20, plot = TRUE)
```

## Conduct model on a subset of 5 eels

Next, a model was applied to a subset of 5 eels with a similar migration path (through the Channel). I want to apply this complex model first on only a few fish before scaling up the complexity. 

### Load packages
```{r}
library(lme4)
library(glmmTMB)
```

### Subset 5 eels for testing
```{r}
subset <- filter(data, ID == "16031" |
                   ID == "17535" |
                   ID == "17536" |
                   ID == "15777" |
                   ID == "17510")

subset$ID <- factor(subset$ID)
unique(subset$ID)

```

### Remove data from eel 17535 when it was in the Atlantic Ocean
For this study I am interested in the vertical movement behaviour on the contintental shelf. The vertical behaviour in oceanic conditions has already been described.
```{r}
subset <- subset[!(subset$ID == "17535" & subset$datetime > '2020-01-11 00:00:00'),]
```


### Depth data processing
```{r}
plot(subset$corrected_depth)
```
```{r}
subset <- filter(subset, corrected_depth < 0)
```
```{r}
plot(subset$corrected_depth)
```

```{r}
subset$corrected_depth_abs <- abs(subset$corrected_depth)
summary(subset$corrected_depth_abs)
```

### Add daily max depth
```{r}
subset2 <- subset %>%
  group_by(ID, Date) %>%
  summarise(max_depth = max(corrected_depth_abs))
subset <- left_join(subset, subset2, by = c("ID","Date"))
```


### Add daily bathymetry based on the trajectory files obtained from the geolocation models

```{r}
# Link trajectory data (source trajectory data script)
tr_data <- read_csv("./data/external/trajectory_data/eel_trajectories.csv")

# Select columns
tr_data <- dplyr::select(tr_data, ID, Date, Max_Depth)
tr_data <- rename(tr_data, 
                  max_depth_bathymetry = Max_Depth)

# Process columns
tr_data$Date <- dmy(tr_data$Date)
tr_data$ID <- factor(tr_data$ID)

# Remove double dates per eel (ID)
#tr_data <- tr_data[!duplicated(tr_data[c('ID','Date')]),]
tr_data <- tr_data %>%     # Add ID number to duplicate dates
  group_by(ID, Date) %>%
  add_tally()

duplicates <- filter(tr_data, n == 2)   # Filter duplicate dates
duplicates <- duplicates %>%             # Add ID number to distinguish between first and second duplicate
  mutate(number_id = row_number())
duplicates <- filter(duplicates, number_id == 2)  # Filter second duplicates

tr_data <- filter(tr_data, n != 2)   # Remove duplicate dates from tracking dataset

# Bind 'duplicates' dataset with second duplicates to tracking dataset
tr_data <- ungroup(tr_data)
tr_data$n <- NULL
duplicates <- ungroup(duplicates)
duplicates$n <- NULL
duplicates$number_id <- NULL

tr_data <- rbind(tr_data, duplicates)

# Select relevant eels
tr_data <- filter(tr_data, ID == "16031" |
                   ID == "17535" |
                   ID == "17536" |
                   ID == "15777" |
                   ID == "17510")

tr_data$ID <- factor(tr_data$ID) # rerun 'factor()' so the number of levels is set accurately

subset$Date <- as.Date(subset$Date)
subset <- left_join(subset, tr_data, by = c('ID', 'Date'))

# Remove line with max depth bathymetry > 300 m --> remove location in deep sea
subset$max_depth_bathymetry <- as.numeric(subset$max_depth_bathymetry)
subset <- filter(subset, max_depth_bathymetry < 300)
```


Plot the daily depth range, the max depth and the max depth bathymetry. The latter 2 do not differ a lot because one of the assumptions in the geolocation model is that the eel's daily depth is the daily max bathymetry.

```{r}
par(mfrow=c(3,1))
plot(subset$Date, subset$corrected_depth_abs)
plot(subset$Date, subset$max_depth)
plot(subset$Date, subset$max_depth_bathymetry)
```


### Calculate the relative depth
```{r}
subset$rel_depth <- subset$corrected_depth_abs / subset$max_depth_bathymetry
plot(subset$Date, subset$rel_depth)
```

### Centralise and normalise exploratory variables
For model construction, the exploratory variables need to be cenralised and normalised by substracting the median of each value and dividing it by the interquantile range

```{r}
# direction_x
summary(subset$direction_x)
iqr <- 0.280  - (-0.252)   #3rd QU - 1st Qu
subset$direction_x_centre <- (subset$direction_x - median(subset$direction_x, na.rm = TRUE))/iqr

# direction_y
summary(subset$direction_y)
iqr <- 0.209 - (-0.176)   #3rd QU - 1st Qu
subset$direction_y_centre <- (subset$direction_y - median(subset$direction_y, na.rm = TRUE))/iqr

# Temperature
summary(subset$temperature)
iqr <- 11.688  - (9.484)   #3rd QU - 1st Qu
subset$temperature_centre <- (subset$temperature - median(subset$temperature))/iqr

# Moon illumination
summary(subset$moon_fraction)
iqr <- 0.7872764   - (0.1450092)   #3rd QU - 1st Qu
subset$moon_fraction_centre <- (subset$moon_fraction - median(subset$moon_fraction))/iqr

# Sun altitude
summary(subset$sun_altitude)
iqr <- 0.1394    - (-0.7882)   #3rd QU - 1st Qu
subset$sun_altitude_centre <- (subset$sun_altitude - median(subset$sun_altitude))/iqr

# Sun azimuth
summary(subset$sun_azimuth)
iqr <- 1.313353  - (-1.306655)   #3rd QU - 1st Qu
subset$sun_azimuth_centre <- (subset$sun_azimuth - median(subset$sun_azimuth))/iqr

# Max depth bathymetry
summary(subset$max_depth_bathymetry)
iqr <-  101.87  - 32.81   #3rd QU - 1st Qu
subset$max_depth_bathymetry_centre <- (subset$max_depth_bathymetry - median(subset$max_depth_bathymetry))/iqr

```

### Construct model with AR1 covariance structure
```{r}
subset <- subset %>%
  arrange(ID, datetime) %>%
  group_by(ID) %>%
  mutate(times = factor(row_number()))
```


The response variable 'rel_depth' contains values > 1. Still need to figure out why. Until then, I just remove the values > 1
```{r}
summary(subset$rel_depth)
subset <- filter(subset, rel_depth < 1)
summary(subset$rel_depth)
```

#### glmer from lme4 package
When running the glmer() function, it gives an error. Not sure why, but based on fora searches it might have to do with the data complexity and/or size.
```{r}
#model_glmer <- glmer(rel_depth ~ direction_x_centre +
#                   direction_y_centre +
#                   moon_fraction_centre +
#                   sun_altitude_centre +
#                   sun_azimuth_centre +
#                 (1|ID),
#                 data = subset,
#                 family = beta_family(),
#                 na.action = na.omit)
#summary(model_glmer)
```

Returns the following error:
```{r}
#  Error in (function (fr, X, reTrms, family, nAGQ = 1L, verbose = 0L, maxit = 100L, : 
#(maxstephalfit) PIRLS step-halvings failed to reduce deviance in pwrssUpdate
```

#### glmmTMB from the glmmTMB package
The function glmmTMB() runs when no AR1 construct is implemented.
For more info on the method implementation, see [this website](https://cran.r-project.org/web/packages/glmmTMB/vignettes/covstruct.html). The [glmmTMB ](https://cran.r-project.org/web/packages/glmmTMB/vignettes/glmmTMB.pdf) R-package was used.
```{r}
model_tmb <- glmmTMB(rel_depth ~ direction_x_centre +
                   direction_y_centre +
                   moon_fraction_centre +
                   sun_altitude_centre +
                   sun_azimuth_centre,
                 data = subset,
                 family = beta_family(),
                 na.action = na.omit)
summary(model_tmb)
```

When the AR1 term is added, a memory error occurs. This is probably due to the fact that this function is rather viable for datasets up to 100k (see [documentation](https://m-clark.github.io/posts/2019-10-20-big-mixed-models/))

```{r}
#model_tmb_ar1 <- glmmTMB(rel_depth ~ direction_x_centre +
#                   direction_y_centre +
#                   moon_fraction_centre +
#                   sun_altitude_centre +
#                   sun_azimuth_centre +
#                 ar1(times + 0 | ID),
#                 family = beta_family(),
#                 data = subset)

```

Returns the following error:
```{r}
#Error: cannot allocate vector of size 4.8 Gb
```

#### bam from the mgcv package
The function bam from the mgcv package is designed for large datasets (see [documentation](https://m-clark.github.io/posts/2019-10-20-big-mixed-models/)).

To implement the AR1 strucgture in the model, select the first record per eel and flag as true.
```{r}
# Select first record per eel and flag as 'TRUE'
t.first <- subset[match(unique(subset$ID), subset$ID),]
t.first <- select(t.first, ID, datetime)
t.first$start.event <- TRUE

# Merge with dataset
subset <- left_join(subset, t.first, by = c("ID", "datetime"))

# Set NA as FALSE
subset[c("start.event")][is.na(subset[c("start.event")])] <- FALSE

```


```{r}
# Run gamm model with autocorrelation argument

# Full model
bam_model <- bam(rel_depth ~ direction_x_centre +
                   direction_y_centre +
                   moon_fraction_centre +
                   sun_altitude_centre +
                   sun_azimuth_centre +
                   s(ID, bs="re"),
                 family = beta_family(), data = subset, discrete = TRUE,
                 AR.start=subset$start.event, rho=0.90,
                 na.action = na.omit)

```

Calculate rho (= acf value) which can be fed into the bam_model for model optimisation.
However, this results in an error for a model of the beta family.
```{r}
# Calculate Rho, the autocorrelation value of a specific lag
#valRho <- acf(resid(bam_model), plot=TRUE)$acf[2]
```

```{r}
#Error in plot.window(...) : need finite 'ylim' values
```

Show summary of the model
```{r}
summary(bam_model)
```



